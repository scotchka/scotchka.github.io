Metaclasses made simple
=======================



.. author:: default
.. categories:: none
.. tags:: none
.. comments::

You probably have added the ``__repr__`` method to a Python class:

.. literalinclude:: meta_cats.py
    :pyobject: Cat

This gives a customized representation to the instance at the command line:

.. literalinclude:: test_meta_cats.py
    :lines: 3-4

However, this ``__repr__`` has no effect on the class itself:

.. code-block:: python

    >>> Cat
    <class '__main__.Cat'>

The reason is that a method defined on a class acts on instances of the class but not
the class itself. But what if the class is itself an instance? An instance of what class?
Python provides an easy way to find out:

.. literalinclude:: test_meta_cats.py
    :lines: 6-7

So we see that a class is an instance of the built-in class ``type``. This means that we
should be able to subclass ``type``, add methods to it, and instantiate classes using
our customized type. Here is a small example:

.. literalinclude:: meta_cats.py
    :pyobject: MetaCat

Note that ``MetaCat`` descends from ``type`` and has a ``__repr__`` method that has a parameter
``cls``. This is to emphasize that instances of ``MetaCat`` are themselves classes.

We can instantiate a class in the usual way, except for an addtional optional parameter.

.. literalinclude:: meta_cats.py
    :pyobject: FancyCat

The ``metaclass`` parameter in the class definition instructs Python to make an instance of ``MetaCat``
instead of ``type``. Let's verify this:

.. literalinclude:: test_meta_cats.py
    :lines: 9-10

Finally, let's see what happens when we evaluate the class ``FancyCat`` on the Python command line:

.. literalinclude:: test_meta_cats.py
    :lines: 12-13

Indeed, the ``__repr__`` method defined on ``MetaCat`` is called, and returns a customized representaion.
