<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Notes and ideas that catch my interest">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Code Miscellany</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/flat.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/font-awesome.min.css" type="text/css">
        <link rel="stylesheet" href="_static/style.css" type="text/css" /><link rel="shortcut icon" href="_static/henry.ico" /><!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="search" title="Search" href="search.html" /><link rel="next" title="Older" href="page2.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script>

    <script type="text/javascript">
        $(document).ready(function () {
            // Scroll to content if on small screen
            if (screen.width < 480)
            {
                $(document).scrollTop(document.getElementsByTagName("article")[0].offsetTop - 44);
            }
        });
    </script></head>
    <body role="document">
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container"><header role="banner">
            <hgroup>
              <h1><a href="#">Code Miscellany</a></h1><h2>Mostly Python</h2></hgroup>
          </header>
      <nav role="navigation">
            <ul><li class="main-nav">
                  <a href="#">Home</a>
                </li>
              </ul>
          </nav><div class="main-container" role="main"><div class="main wrapper body clearfix"><article><div class="timestamp postmeta">
            <span>November 18, 2019</span>
        </div>
        <div class="section">
            <h1><a href="2019/11/18/a_recursive_main_function.html">A recursive main function</a></h1>
<p>In languages such as C, there is a privileged function - <span class="docutils literal"><span class="pre">main</span></span> - that
is the entry point for execution. Running the program is tantamount to
calling <span class="docutils literal"><span class="pre">main</span></span>, which in turn calls other functions.</p>
<p>Since <span class="docutils literal"><span class="pre">main</span></span> is a name in the global namespace, there is nothing to prevent
it from calling itself. Consider this recursive <span class="docutils literal"><span class="pre">main</span></span> function that
calculates the factorial:</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">main.c</span></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

  <span class="n">static</span> <span class="nb">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">"error: need argument</span><span class="se">\n</span><span class="s2">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">acc</span><span class="p">;</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">"</span><span class="si">%d</span><span class="s2">"</span><span class="p">,</span> <span class="o">--</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p><span class="docutils literal"><span class="pre">main</span></span> takes two inputs. <span class="docutils literal"><span class="pre">argc</span></span> is the number of command line arguments,
and <span class="docutils literal"><span class="pre">argv</span></span> is an array of those arguments. The library function <span class="docutils literal"><span class="pre">atoi</span></span>
converts a string to the integer it represents, and <span class="docutils literal"><span class="pre">sprintf</span></span> prints
to a string rather than standard output. So we decrement <span class="docutils literal"><span class="pre">n</span></span> with each recursive
call until the base case is reached, and print out the result. The accumulator <span class="docutils literal"><span class="pre">acc</span></span>
is a static variable, which means it persists across function calls.</p>
<p>Here is an example output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ gcc main.c
$ ./a.out 5
120
</pre></div>
</div>
<p>The fact that this programs works is convincing evidence that <span class="docutils literal"><span class="pre">main</span></span>, other than being
the entry point, is an ordinary function that can be called from another part of
the code, including from itself.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>March 30, 2019</span>
        </div>
        <div class="section">
            <h1><a href="2019/03/30/why_is_an_omnivore_a_kind_of_vegetarian.html">Why is an omnivore a kind of vegetarian?</a></h1>
<p>An important principle in object oriented design is that you can replace an object of one class with another object
of its subclass, and the code should still work. For example, suppose we are creating a calorie counter for various
foods. We have a parent class</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Food</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">calories</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calories</span> <span class="o">=</span> <span class="n">calories</span>
</pre></div>
</div>
<p>and child classes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Vegetable</span><span class="p">(</span><span class="n">Food</span><span class="p">):</span>
    <span class="n">is_leafy</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Meat</span><span class="p">(</span><span class="n">Food</span><span class="p">):</span>
    <span class="n">is_bloody</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Consider a function that returns the calories of an item of food:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">get_calories</span><span class="p">(</span><span class="n">food</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">food</span><span class="o">.</span><span class="n">calories</span>
</pre></div>
</div>
<p>Because a child class inherits the methods and attributes from its parent class -
possibly overriding some and adding others - any code that expects <span class="docutils literal"><span class="pre">Food</span></span> will
also work with <span class="docutils literal"><span class="pre">Vegetable</span></span> and <span class="docutils literal"><span class="pre">Meat</span></span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">get_calories</span><span class="p">(</span><span class="n">Food</span><span class="p">(</span><span class="s1">'gruel'</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_calories</span><span class="p">(</span><span class="n">Vegetable</span><span class="p">(</span><span class="s1">'potato'</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_calories</span><span class="p">(</span><span class="n">Meat</span><span class="p">(</span><span class="s1">'steak'</span><span class="p">,</span> <span class="mi">500</span><span class="p">))</span>
<span class="go">500</span>
</pre></div>
</div>
<p>This ability to replace with a subclass is known as the “Liskov Substitution Principle”.</p>
<p>Now let’s turn to the consumers of food. Here is a possible class hierarchy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Omnivore</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">"YUM!"</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Vegetarian</span><span class="p">(</span><span class="n">Omnivore</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">food</span><span class="p">,</span> <span class="n">Vegetable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">food</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">" EWW"</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">food</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Carnivore</span><span class="p">(</span><span class="n">Omnivore</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">food</span><span class="p">,</span> <span class="n">Meat</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">food</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">" EWW"</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">food</span><span class="p">)</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">Vegetarian</span></span> and <span class="docutils literal"><span class="pre">Carnivore</span></span> override the <span class="docutils literal"><span class="pre">eat</span></span> method of <span class="docutils literal"><span class="pre">Omnivore</span></span> to raise an exception when
fed an argument that violates their respective dietary restrictions. An omnivore can consume both <span class="docutils literal"><span class="pre">Vegetable</span></span>
and <span class="docutils literal"><span class="pre">Meat</span></span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Omnivore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Vegetable</span><span class="p">(</span><span class="s1">'potato'</span><span class="p">))</span>
<span class="go">potato YUM!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Meat</span><span class="p">(</span><span class="s1">'steak'</span><span class="p">))</span>
<span class="go">steak YUM!</span>
</pre></div>
</div>
<p>But a vegetarian cannot consume <span class="docutils literal"><span class="pre">Meat</span></span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Vegetarian</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Vegetable</span><span class="p">(</span><span class="s1">'potato'</span><span class="p">))</span>
<span class="go">potato YUM!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Meat</span><span class="p">(</span><span class="s1">'steak'</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">Exception</span>: <span class="n">steak EWW</span>
</pre></div>
</div>
<p>The code breaks when an <span class="docutils literal"><span class="pre">Omnivore</span></span> is replaced by a <span class="docutils literal"><span class="pre">Vegetarian</span></span>. Therefore, the
Liskov Substitution Principle implies, perhaps counterintuitively, that <span class="docutils literal"><span class="pre">Vegetarian</span></span>
is not a subclass of <span class="docutils literal"><span class="pre">Omnivore</span></span>.</p>
<p>This dilemma is resolved by observing that a <span class="docutils literal"><span class="pre">Vegetarian</span></span> can be replaced by an <span class="docutils literal"><span class="pre">Omnivore</span></span>,
and hence the class hierarchy should be inverted - <span class="docutils literal"><span class="pre">Omnivore</span></span> being a subclass of <span class="docutils literal"><span class="pre">Vegetarian</span></span>.
Of course, we can repeat the argument for <span class="docutils literal"><span class="pre">Carnivore</span></span>, so <span class="docutils literal"><span class="pre">Omnivore</span></span> inherits from both
<span class="docutils literal"><span class="pre">Vegetarian</span></span> and <span class="docutils literal"><span class="pre">Carnivore</span></span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Vegetarian</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">food</span><span class="p">,</span> <span class="n">Vegetable</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">food</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">"YUM!"</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Carnivore</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">food</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">food</span><span class="p">,</span> <span class="n">Meat</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">food</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">"YUM!"</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Omnivore</span><span class="p">(</span><span class="n">Vegetarian</span><span class="p">,</span> <span class="n">Carnivore</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The key difference here is that, instead of raising an error, <span class="docutils literal"><span class="pre">Vegetarian</span></span> and <span class="docutils literal"><span class="pre">Carnivore</span></span> pass
the call to <span class="docutils literal"><span class="pre">eat</span></span> up the inheritance chain, hoping that another class is able to accept
the kind of food. The implementation of <span class="docutils literal"><span class="pre">Omnivore</span></span> is now trivial and intuitive - nothing more than the union of the consumers of <span class="docutils literal"><span class="pre">Vegetable</span></span> and <span class="docutils literal"><span class="pre">Meat</span></span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Vegetarian</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Vegetable</span><span class="p">(</span><span class="s1">'potato'</span><span class="p">))</span>
<span class="go">potato YUM!</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Omnivore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Vegetable</span><span class="p">(</span><span class="s1">'potato'</span><span class="p">))</span>
<span class="go">potato YUM!</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Carnivore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Meat</span><span class="p">(</span><span class="s1">'steak'</span><span class="p">))</span>
<span class="go">steak YUM!</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span> <span class="o">=</span> <span class="n">Omnivore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">guest</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">Meat</span><span class="p">(</span><span class="s1">'steak'</span><span class="p">))</span>
<span class="go">steak YUM!</span>
</pre></div>
</div>
<p>We see that a <span class="docutils literal"><span class="pre">Vegetarian</span></span> or <span class="docutils literal"><span class="pre">Carnivore</span></span> can be replaced by an <span class="docutils literal"><span class="pre">Omnivore</span></span>, so
our class hierarchy obeys Liskov Substitution. This example also illustrates a general rule:
a method of the child class should accept an argument that is less restrictive
(or not more restrictive) than the
corresponding method of the parent class. An <span class="docutils literal"><span class="pre">Omnivore</span></span> can eat either <span class="docutils literal"><span class="pre">Vegetable</span></span> or <span class="docutils literal"><span class="pre">Meat</span></span>,
whereas a <span class="docutils literal"><span class="pre">Vegetarian</span></span> or <span class="docutils literal"><span class="pre">Carnivore</span></span> can only eat one of the food classes. In other words,
even though a child class is more specific than its parent, the child’s methods take arguments
that are more general. This property of arguments is known as “contravariance”.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>December 31, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/12/31/building_a_data_structure_with_nothing_but_functions.html">Building a data structure with nothing but functions</a></h1>
<p>A simple but far reaching consequence of being able to nest functions is that
data can be stored in the enclosing scope  - or closure - of
the inner function. Consider the following function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">make_node</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">next_node</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">next_node</span><span class="p">)</span>
</pre></div>
</div>
<p>When <span class="docutils literal"><span class="pre">make_node</span></span> is called with two arguments, they are attached to the closure
of the returned function. Subsequently, we can access the two arguments via</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">next_node</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">next_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="k">lambda</span> <span class="n">value</span><span class="p">,</span> <span class="n">next_node</span><span class="p">:</span> <span class="n">next_node</span><span class="p">)</span>
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">node</span> <span class="o">=</span> <span class="n">make_node</span><span class="p">(</span><span class="s2">"head"</span><span class="p">,</span> <span class="s2">"tail"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="go">'head'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">next_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="go">'tail'</span>
</pre></div>
</div>
<p>With these functions in hand, it is easy to implement a stack as a linked list.
We define the usual stack operations</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">make_node</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">(</span><span class="n">stack</span><span class="p">),</span> <span class="n">next_node</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</pre></div>
</div>
<p>The behavior is as expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="go">1</span>
</pre></div>
</div>
<p>It is remarkable that this stack does not use any built-in data structure such as an array, nor does it
build the linked list by instantiating node objects. Rather, there is a chain of functions wherein each
function’s closure contains a value and a reference to the next function.</p>
<p>This discussion was inspired by the classic
<a class="reference external" href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">Structure and Interpretation of Computer Programs</a>.
In particular, section 2.1 introduces the notion of using closures to build data structures.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>November 15, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/11/15/stackless_merge_sort.html">Stackless merge sort</a></h1>
<p>Merge sort divides a list into smaller lists of one or zero items, which
are trivially sorted, and then merges them pairwise until one list remains.
Here is a typical recursive implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">mergesort</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lst</span><span class="p">[:]</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">mergesort</span><span class="p">(</span><span class="n">lst</span><span class="p">[:</span><span class="n">mid</span><span class="p">]),</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="n">mid</span><span class="p">:]))</span>
</pre></div>
</div>
<p>Note that the base case returns a copy, not the original list, to be
consistent with the general behavior. The <span class="docutils literal"><span class="pre">merge</span></span> function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">merged</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">merged</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged</span>
</pre></div>
</div>
<p>For simplicity, we use <span class="docutils literal"><span class="pre">pop(0)</span></span> which is inefficient but easily remedied
with indexing.</p>
<p>Instead of dividing the list recursively, we can put each item into a list
by itself, and then merge them iteratively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">mergesort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">merged</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We maintain the individual lists in a queue. In each iteration, we take two lists from the queue,
merge them, and put the combined list back in the queue. Eventually just one list remains, which is
the desired result. The queue ensures that smaller lists are merged before larger ones, so that the
pair being merged does not become too different in size - unbalanced pairs would degrade runtime.</p>
<p>Checking a test case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mergesort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>November 08, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/11/08/stackless_quicksort.html">Stackless quicksort</a></h1>
<p>Quicksort is a famous example of a recursive algorithm. Here is a sub-optimal
implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">qsort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">pivot_position</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="n">qsort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">pivot_position</span><span class="p">)</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">pivot_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">partition</span></span> function chooses a pivot value and places it at the correct position, with smaller values
to its left and larger values to its right. It also returns the final position of the pivot value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">end</span><span class="p">]</span>

    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>

    <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>

    <span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</pre></div>
</div>
<p>For brevity, we use list slicing instead of swaps, but the discussion does not
depend on how the partitioning is done.</p>
<p>In the above implementation, observe that each recursive call stands alone, simply sorting a
segment of the list. As this <a class="reference external" href="https://bertrandmeyer.com/2014/12/07/lampsort/">article</a> points out,
the recursive call stack serves merely to ensure that the list is divided into smaller segments
until every item is a pivot or belongs to a segment of one item.</p>
<p>Because the order in which different parts of the list is sorted is immaterial, we don’t need recursion
or even a stack for that matter. Here is an implementation of quicksort using a set to track which segments
are still to be sorted:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">qsort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">not_sorted</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">))}</span>

    <span class="k">while</span> <span class="n">not_sorted</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">not_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">pivot_position</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pivot_position</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">not_sorted</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">pivot_position</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="n">pivot_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">not_sorted</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pivot_position</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
</pre></div>
</div>
<p>The set <span class="docutils literal"><span class="pre">not_sorted</span></span> contains start and end indices of segments which remain to be sorted. Note that
the <span class="docutils literal"><span class="pre">pop</span></span> method returns an <strong>arbitrary</strong> element of a set, which becomes empty when no unsorted segments
remain. The list is then sorted. Let’s check a test case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>October 09, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/10/09/instantiating_functions_and_modules.html">Instantiating functions and modules</a></h1>
<p>In Python, anything that you can assign to a variable is an object, including a function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">inc</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>
<span class="go">&lt;class 'function'&gt;</span>
</pre></div>
</div>
<p>Normally, Python creates a function object upon function definition, but we can also
instantiate a function like other objects - by calling its class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Function</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="vm">__code__</span><span class="p">,</span> <span class="p">{</span><span class="s1">'x'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The class <span class="docutils literal"><span class="pre">Function</span></span> takes two required arguments. First, a code object which is a data
structure containing compiled bytecode. Second, a dictionary that is the global scope
of the resulting function. Indeed, calling the original <span class="docutils literal"><span class="pre">inc</span></span> would raise an error since
<span class="docutils literal"><span class="pre">x</span></span> is not defined, but <span class="docutils literal"><span class="pre">another_inc</span></span> works because its global scope does have <span class="docutils literal"><span class="pre">x</span></span>.</p>
<p>More generally, the global scope of a function is the module that contains it. Let’s confirm
this with a function from a standard module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match</span><span class="o">.</span><span class="vm">__globals__</span> <span class="ow">is</span> <span class="n">re</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A module is a simple object whose main purpose is to hold objects that belong to it - in
other words, provide a namespace. It turns out that we can also dynamically instantiate a
module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Module</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span><span class="s1">'another module'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
<span class="go">['__doc__', '__loader__', '__name__', '__package__', '__spec__']</span>
</pre></div>
</div>
<p>Finally, we change the global scope of our existing function to the new module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="o">.</span><span class="vm">__globals__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="p">()</span>
<span class="go">43</span>
</pre></div>
</div>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>August 20, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/08/20/little_endian.html">Determining endianness</a></h1>
<p>“Endianness” is how the digits in a number are arranged.
Humans write numbers from the most significant digit to the least significant
digit. This order is called “big-endian” – big end first. The reverse is called
“little-endian”.</p>
<p>In computer memory, a number is represented as a consecutive sequence of bits. A <strong>long</strong> integer takes
up 8 bytes (64 bits), for example.
This raises a question: does the lowest address byte represent the most significant or the least
sigificant digits of the number?</p>
<p>To decide this, we can run a short C program:</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">endian.c</span></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="c1">#include &lt;stdio.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">unsigned</span> <span class="n">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>

  <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sizeof</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="s2"> "</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>For simplicity, we initialize an <cite>unsigned long</cite> and assign its address
to a pointer to an <cite>unsigned char</cite>. This means that if we add an integer to the pointer,
the resulting address will advance by that many bytes. Simply put, we print the base 256
representation of the long integer.</p>
<p>The output on an Intel x86 machine is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ gcc endian.c
$ ./a.out
0 0 1 0 0 0 0 0
</pre></div>
</div>
<p>The third and only nonzero byte is 1. This establishes that the integer is stored in memory in
little-endian fashion.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>July 21, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/07/21/self_referential_markov.html">Self-referential data structures</a></h1>
<p>Most data structures in Python can hold arbitrary heterogenous data. This is because
the underlying C structures contain pointers to other locations in memory. For example,
a Python list is implemented in C as an array of pointers.</p>
<p>A perhaps startling consequence is that a mutable data structure - such as a list - can
contain itself as an element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">lst</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A self-referential data structure, though somewhat obscure, can be more compact.
As a use case, let’s consider the familiar exercise of a Markov chain text generator.</p>
<p>Given a string, we construct a list of consecutive pairs - or bigrams - of words that appear. For
each unique bigram, its second word may be the first word in multiple other bigrams. We
randomly choose one such bigram, and repeat the process. The sequence of words encountered
in this random series of jumps through the text constitutes the Markov text.</p>
<p>First, we define a function to make a data structure that allows for random traversal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">make_chain</span><span class="p">(</span><span class="n">raw_text</span><span class="p">):</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">raw_text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="n">chain</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">bigrams</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">words</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="o">+</span> <span class="p">[(</span><span class="n">words</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bigram</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bigrams</span><span class="p">):</span>
        <span class="n">next_bigram</span> <span class="o">=</span> <span class="n">bigrams</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">bigrams</span><span class="p">)]</span>

        <span class="n">chain</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">next_bigram</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">bigram</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">next_links</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">bigram</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">next_links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">next_bigram</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">chain</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">chain</span></span> is self-referential because the <span class="docutils literal"><span class="pre">append</span></span> method, which adds to a list inside
<span class="docutils literal"><span class="pre">chain</span></span>, takes as argument a component of <span class="docutils literal"><span class="pre">chain</span></span> itself. We can gain more insight with
a small example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">make_chain</span><span class="p">(</span><span class="s1">'a a a b'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bigram</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">bigram</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span>
<span class="go">{('a', 'a'): [{...}, {('a', 'b'): [{('b', 'a'): [{...}]}]}]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span><span class="p">[</span><span class="n">bigram</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">link</span>
<span class="go">True</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">link</span></span> is a dictionary of one key-value pair. The key is a bigram, and the value is a list
of dictionaries, each having the same structure as <span class="docutils literal"><span class="pre">link</span></span>. Though the structure is finite,
we can “descend” into it indefinitely. This suggests a simple strategy for random traversal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">make_text</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>

    <span class="n">link</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="n">text</span> <span class="o">=</span> <span class="s2">""</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">140</span><span class="p">:</span>
        <span class="n">bigram</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="n">bigram</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">" "</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="n">bigram</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">text</span>
</pre></div>
</div>
<p>Let’s generate a random text based on a famous work of literature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="gp">... </span><span class="s2">Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s2">Explicit is better than implicit.</span>
<span class="gp">... </span><span class="s2">Simple is better than complex.</span>
<span class="gp">... </span><span class="s2">Complex is better than complicated.</span>
<span class="gp">... </span><span class="s2">Flat is better than nested.</span>
<span class="gp">... </span><span class="s2">Sparse is better than dense."""</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">make_chain</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_text</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
<span class="go">'than ugly. Explicit is better than implicit. Simple is better than ugly. Explicit is better than nested. Sparse is better than complicated. '</span>
</pre></div>
</div>
<p>To be sure, compared to the usual implementations of Markov text generation, this version
is quite inscrutable. It is to be taken as a proof of principle. You should almost always
avoid self-referential data structures in production code!</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>July 13, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/07/13/tree_traversal_the_hard_way.html">Tree traversal made hard</a></h1>
<p>Tree traversal is a well known task for which recursion is simple and natural. We define a Node
class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span>
            <span class="n">values</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">make_tree</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="n">mid</span><span class="p">]),</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">make_tree</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]),</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>The class method <span class="docutils literal"><span class="pre">make_tree</span></span> returns the root node of a balanced binary tree from a list of values.
If the list is sorted, then the tree is a binary search tree (BST). A BST has the important property
that if you do an in-order traversal of the nodes, you will visit them in order.
A recursive implementation of in-order traversal is straightforward.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="n">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s test it with a small sorted list of integers and verify that the nodes are printed out in order.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">make_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Now, what if we insist on traversing <strong>without</strong> recursion? In lieu of the call stack, we need to
maintain our own stack. Each item in our stack would hold the same information as a call frame.
In <span class="docutils literal"><span class="pre">traverse_recursive</span></span> there are two potential recursive calls, each call adding another frame to
the call stack. Since a recursive call suspends the calling frame, our stack must maintain a
state - whether or not the left side of the BST has been examined. Let’s designate the possibilities
for this state <span class="docutils literal"><span class="pre">"left"</span></span> and <span class="docutils literal"><span class="pre">"right"</span></span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_iterative</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"left"</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"right"</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
</pre></div>
</div>
<p>Each call frame becomes, in our stack, a pair of items - as the stack is popped off, the left side of
each node is examined before the right. The analogue of a recursive call is pushing another pair to the stack.
Let’s test <span class="docutils literal"><span class="pre">traverse_iterative</span></span> on the same BST.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_iterative</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Note that an in-order traversal is different from a depth-first search (DFS). To implement DFS iteratively,
we simply maintain a stack of nodes without the additional state. This is because DFS first checks whether
the target node has been found (and if so, exits) <strong>before</strong> adding the child nodes to the stack. Hence there
is no reason to “remember” the parent node. Formally, DFS on a binary tree is equivalent to a pre-order traversal.</p>
<p>The iterative implementation of in-order tree traversal is less intuitive than the recursive version, which nicely
illustrates that recursion is sometimes <strong>much easier</strong> than iteration. Though iteration has the advantage
of not growing the call stack, and readily leads to tail recursion.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_tail_recursive</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">node</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"left"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"right"</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>

    <span class="n">traverse_tail_recursive</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <span class="docutils literal"><span class="pre">traverse_tail_recursive</span></span> with the same tree but wrapped inside of a stack:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_tail_recursive</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Python does not offer tail call optimization, but in languages that do, this example suggests a recipe
for turning a recursive function into a tail recursive function: via an intermediate iterative implementation.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>July 09, 2018</span>
        </div>
        <div class="section">
            <h1><a href="2018/07/09/metaclass_intro.html">Metaclasses made simple</a></h1>
<p>You probably have added the <span class="docutils literal"><span class="pre">__repr__</span></span> method to a Python class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"&lt;😻&gt;"</span>
</pre></div>
</div>
<p>This gives a customized representation to the instance at the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Cat</span><span class="p">()</span>
<span class="go">&lt;😻&gt;</span>
</pre></div>
</div>
<p>However, this <span class="docutils literal"><span class="pre">__repr__</span></span> has no effect on the class itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Cat</span>
<span class="go">&lt;class 'meta_cats.Cat'&gt;</span>
</pre></div>
</div>
<p>The reason is that a method defined on a class acts on instances of the class but not
the class itself. But what if the class is itself an instance? An instance of what class?
Python provides an easy way to find out:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span>
<span class="go">&lt;class 'type'&gt;</span>
</pre></div>
</div>
<p>So we see that a class is an instance of the built-in class <span class="docutils literal"><span class="pre">type</span></span>. This means that we
should be able to subclass <span class="docutils literal"><span class="pre">type</span></span>, add methods to it, and instantiate classes using
our customized type. Here is a small example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">MetaCat</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">repr_string</span>
</pre></div>
</div>
<p>Note that <span class="docutils literal"><span class="pre">MetaCat</span></span> descends from <span class="docutils literal"><span class="pre">type</span></span> and has a <span class="docutils literal"><span class="pre">__repr__</span></span> method that has a parameter
<span class="docutils literal"><span class="pre">cls</span></span>. This is to emphasize that instances of <span class="docutils literal"><span class="pre">MetaCat</span></span> are themselves classes.</p>
<p>We can instantiate a class in the usual way, except for an additional optional parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FancyCat</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaCat</span><span class="p">):</span>
    <span class="n">repr_string</span> <span class="o">=</span> <span class="s2">"&lt;class 😻&gt;"</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">metaclass</span></span> parameter in the class definition instructs Python to make an instance of <span class="docutils literal"><span class="pre">MetaCat</span></span>
instead of <span class="docutils literal"><span class="pre">type</span></span>. Let’s verify this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">FancyCat</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MetaCat</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, let’s see what happens when we evaluate the class <span class="docutils literal"><span class="pre">FancyCat</span></span> on the Python command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">FancyCat</span>
<span class="go">&lt;class 😻&gt;</span>
</pre></div>
</div>
<p>Indeed, the <span class="docutils literal"><span class="pre">__repr__</span></span> method defined on <span class="docutils literal"><span class="pre">MetaCat</span></span> is called, and returns a customized representaion.</p>
<p>To summarize, every class in Python is an instance of some class, often referred to as a metaclass to
distinguish it from other classes. <span class="docutils literal"><span class="pre">type</span></span> is the built-in metaclass of which <span class="docutils literal"><span class="pre">int</span></span>, <span class="docutils literal"><span class="pre">dict</span></span>, and your own
classes are instances. And just like with most classes, you can subclass <span class="docutils literal"><span class="pre">type</span></span> to make custom metaclasses,
analogous to subclassing <span class="docutils literal"><span class="pre">object</span></span> to make custom classes.</p>

        </div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Henry Chen</span>
        </div>
        
        
        </div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="page2.html">Older</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2019/11/18/a_recursive_main_function.html">A recursive main function</a>
        </li><li>
            <a href="2019/03/30/why_is_an_omnivore_a_kind_of_vegetarian.html">Why is an omnivore a kind of vegetarian?</a>
        </li><li>
            <a href="2018/12/31/building_a_data_structure_with_nothing_but_functions.html">Building a data structure with nothing but functions</a>
        </li><li>
            <a href="2018/11/15/stackless_merge_sort.html">Stackless merge sort</a>
        </li><li>
            <a href="2018/11/08/stackless_quicksort.html">Stackless quicksort</a>
        </li><li>
            <a href="2018/10/09/instantiating_functions_and_modules.html">Instantiating functions and modules</a>
        </li><li>
            <a href="2018/08/20/little_endian.html">Determining endianness</a>
        </li><li>
            <a href="2018/07/21/self_referential_markov.html">Self-referential data structures</a>
        </li><li>
            <a href="2018/07/13/tree_traversal_the_hard_way.html">Tree traversal made hard</a>
        </li><li>
            <a href="2018/07/09/metaclass_intro.html">Metaclasses made simple</a>
        </li></ul>
</div>
</section><section><div class="widget" id="searchbox" role="search">
    <h1><a href="#searchbox">Search</a></h1>
    <form action="search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="fa fa-search"></span></button>
    </form>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container" role="contentinfo">
    <footer class="wrapper">&copy; Copyright 2018 - 2019, Henry Chen. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121190098-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121190098-1');
</script>
</div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>