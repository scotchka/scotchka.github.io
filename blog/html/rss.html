<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Code Miscellany</title>
        <link>https://scotchka.github.io/blog/html/</link>
        <description>Mostly Python</description>
        <language>en-us</language>
        <pubDate>Thu, 08 Nov 2018 00:00:00 -0800</pubDate>
        
        <item>
            <link>https://scotchka.github.io/blog/html/2018/11/08/stackless_quicksort.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/11/08/stackless_quicksort.html</guid>
            <title><![CDATA[Stackless quicksort]]></title>
            <description><![CDATA[<h1>Stackless quicksort</h1>
<p>Quicksort is a famous example of a recursive algorithm. Here is a sub-optimal
implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">qsort_recursive</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>

    <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>

    <span class="n">qsort_recursive</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">))</span>
    <span class="n">qsort_recursive</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">end</span><span class="p">)</span>
</pre></div>
</div>
<p>For brevity, we use list slicing instead of swaps, but the discussion does not
depend on how the partitioning is done.</p>
<p>Let‚Äôs check that it works for a simple case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort_recursive</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>In the above implementation, observe that each recursive call stands alone, simply sorting a
segment of the list. As this <a class="reference external" href="https://bertrandmeyer.com/2014/12/07/lampsort/">article</a> points out,
the recursive call stack serves merely to ensure that the list is divided into smaller segments
until every item is a pivot or belongs to a segment of one item.</p>
<p>Because the order in which different parts of the list is sorted is immaterial, we don‚Äôt need recursion
or even a stack for that matter. Here is an implementation of quicksort using a set to track which segments
are still to be sorted:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">qsort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="n">not_sorted</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">))}</span>

    <span class="k">while</span> <span class="n">not_sorted</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">not_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="n">segment</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="n">pivot</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">segment</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>

        <span class="n">lst</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">not_sorted</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">not_sorted</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="n">end</span><span class="p">))</span>
</pre></div>
</div>
<p>The set <span class="docutils literal"><span class="pre">not_sorted</span></span> contains start and end indices of segments which remain to be sorted. Note that
the <span class="docutils literal"><span class="pre">pop</span></span> method returns an <strong>arbitrary</strong> element of a set, which becomes empty when no unsorted segments
remain. The list is then sorted. Let‚Äôs check the same test case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort_stackless</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span>
<span class="go">[1, 2, 3, 4, 5]</span>
</pre></div>
</div>
]]></description>
             <pubDate>Thu, 08 Nov 2018 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/10/09/instantiating_functions_and_modules.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/10/09/instantiating_functions_and_modules.html</guid>
            <title><![CDATA[Instantiating functions and modules]]></title>
            <description><![CDATA[<h1>Instantiating functions and modules</h1>
<p>In Python, anything that you can assign to a variable is an object, including a function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">inc</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>
<span class="go">&lt;class 'function'&gt;</span>
</pre></div>
</div>
<p>Normally, Python creates a function object upon function definition, but we can also
instantiate a function like other objects - by calling its class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Function</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">inc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">inc</span><span class="o">.</span><span class="vm">__code__</span><span class="p">,</span> <span class="p">{</span><span class="s1">'x'</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The class <span class="docutils literal"><span class="pre">Function</span></span> takes two required arguments. First, a code object which is a data
structure containing compiled bytecode. Second, a dictionary that is the global scope
of the resulting function. Indeed, calling the original <span class="docutils literal"><span class="pre">inc</span></span> would raise an error since
<span class="docutils literal"><span class="pre">x</span></span> is not defined, but <span class="docutils literal"><span class="pre">another_inc</span></span> works because its global scope does have <span class="docutils literal"><span class="pre">x</span></span>.</p>
<p>More generally, the global scope of a function is the module that contains it. Let‚Äôs confirm
this with a function from a standard module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">re</span> <span class="k">import</span> <span class="n">match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match</span><span class="o">.</span><span class="vm">__globals__</span> <span class="ow">is</span> <span class="n">re</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A module is a simple object whose main purpose is to hold objects that belong to it - in
other words, provide a namespace. It turns out that we can also dynamically instantiate a
module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Module</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span><span class="s1">'another module'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
<span class="go">['__doc__', '__loader__', '__name__', '__package__', '__spec__']</span>
</pre></div>
</div>
<p>Finally, we change the global scope of our existing function to the new module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">mod</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="o">.</span><span class="vm">__globals__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">another_inc</span><span class="p">()</span>
<span class="go">43</span>
</pre></div>
</div>
]]></description>
             <pubDate>Tue, 09 Oct 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/08/20/little_endian.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/08/20/little_endian.html</guid>
            <title><![CDATA[Determining endianness]]></title>
            <description><![CDATA[<h1>Determining endianness</h1>
<p>‚ÄúEndianness‚Äù is how the digits in a number are arranged.
Humans write numbers from the most significant digit to the least significant
digit. This order is called ‚Äúbig-endian‚Äù ‚Äì big end first. The reverse is called
‚Äúlittle-endian‚Äù.</p>
<p>In computer memory, a number is represented as a consecutive sequence of bits. A <strong>long</strong> integer takes
up 8 bytes (64 bits), for example.
This raises a question: does the lowest address byte represent the most significant or the least
sigificant digits of the number?</p>
<p>To decide this, we can run a short C program:</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">endian.c</span></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="c1">#include &lt;stdio.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">unsigned</span> <span class="n">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>

  <span class="nb">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sizeof</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="s2"> "</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>For simplicity, we initialize an <cite>unsigned long</cite> and assign its address
to a pointer to an <cite>unsigned char</cite>. This means that if we add an integer to the pointer,
the resulting address will advance by that many bytes. Simply put, we print the base 256
representation of the long integer.</p>
<p>The output on an Intel x86 machine is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/>$ gcc endian.c
$ ./a.out
0 0 1 0 0 0 0 0
</pre></div>
</div>
<p>The third and only nonzero byte is 1. This establishes that the integer is stored in memory in
little-endian fashion.</p>
]]></description>
             <pubDate>Mon, 20 Aug 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/07/21/self_referential_markov.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/07/21/self_referential_markov.html</guid>
            <title><![CDATA[Self-referential data structures]]></title>
            <description><![CDATA[<h1>Self-referential data structures</h1>
<p>Most data structures in Python can hold arbitrary heterogenous data. This is because
the underlying C structures contain pointers to other locations in memory. For example,
a Python list is implemented in C as an array of pointers.</p>
<p>A perhaps startling consequence is that a mutable data structure - such as a list - can
contain itself as an element:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span>
<span class="go">[1, 2, 3, [...]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">lst</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A self-referential data structure, though somewhat obscure, can be more compact.
As a use case, let‚Äôs consider the familiar exercise of a Markov chain text generator.</p>
<p>Given a string, we construct a list of consecutive pairs - or bigrams - of words that appear. For
each unique bigram, its second word may be the first word in multiple other bigrams. We
randomly choose one such bigram, and repeat the process. The sequence of words encountered
in this random series of jumps through the text constitutes the Markov text.</p>
<p>First, we define a function to make a data structure that allows for random traversal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">make_chain</span><span class="p">(</span><span class="n">raw_text</span><span class="p">):</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">raw_text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="n">chain</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">bigrams</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">words</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span> <span class="o">+</span> <span class="p">[(</span><span class="n">words</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bigram</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bigrams</span><span class="p">):</span>
        <span class="n">next_bigram</span> <span class="o">=</span> <span class="n">bigrams</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">bigrams</span><span class="p">)]</span>

        <span class="n">chain</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">next_bigram</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">bigram</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">next_links</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">bigram</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">next_links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="n">next_bigram</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">chain</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">chain</span></span> is self-referential because the <span class="docutils literal"><span class="pre">append</span></span> method, which adds to a list inside
<span class="docutils literal"><span class="pre">chain</span></span>, takes as argument a component of <span class="docutils literal"><span class="pre">chain</span></span> itself. We can gain more insight with
a small example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">make_chain</span><span class="p">(</span><span class="s1">'a a a b'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bigram</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">bigram</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span>
<span class="go">{('a', 'a'): [{...}, {('a', 'b'): [{('b', 'a'): [{...}]}]}]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">link</span><span class="p">[</span><span class="n">bigram</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">link</span>
<span class="go">True</span>
</pre></div>
</div>
<p><span class="docutils literal"><span class="pre">link</span></span> is a dictionary of one key-value pair. The key is a bigram, and the value is a list
of dictionaries, each having the same structure as <span class="docutils literal"><span class="pre">link</span></span>. Though the structure is finite,
we can ‚Äúdescend‚Äù into it indefinitely. This suggests a simple strategy for random traversal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">make_text</span><span class="p">(</span><span class="n">chain</span><span class="p">):</span>

    <span class="n">link</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="n">text</span> <span class="o">=</span> <span class="s2">""</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">140</span><span class="p">:</span>
        <span class="n">bigram</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">link</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">text</span> <span class="o">+</span> <span class="n">bigram</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">" "</span>
        <span class="n">link</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="n">bigram</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">text</span>
</pre></div>
</div>
<p>Let‚Äôs generate a random text based on a famous work of literature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="gp">... </span><span class="s2">Beautiful is better than ugly.</span>
<span class="gp">... </span><span class="s2">Explicit is better than implicit.</span>
<span class="gp">... </span><span class="s2">Simple is better than complex.</span>
<span class="gp">... </span><span class="s2">Complex is better than complicated.</span>
<span class="gp">... </span><span class="s2">Flat is better than nested.</span>
<span class="gp">... </span><span class="s2">Sparse is better than dense."""</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">make_chain</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">make_text</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
<span class="go">'than ugly. Explicit is better than implicit. Simple is better than ugly. Explicit is better than nested. Sparse is better than complicated. '</span>
</pre></div>
</div>
<p>To be sure, compared to the usual implementations of Markov text generation, this version
is quite inscrutable. It is to be taken as a proof of principle. You should almost always
avoid self-referential data structures in production code!</p>
]]></description>
             <pubDate>Sat, 21 Jul 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/07/13/tree_traversal_the_hard_way.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/07/13/tree_traversal_the_hard_way.html</guid>
            <title><![CDATA[Tree traversal made hard]]></title>
            <description><![CDATA[<h1>Tree traversal made hard</h1>
<p>Tree traversal is a well known task for which recursion is simple and natural. We define a Node
class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">make_tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span>
            <span class="n">values</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">make_tree</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="n">mid</span><span class="p">]),</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">make_tree</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]),</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>The class method <span class="docutils literal"><span class="pre">make_tree</span></span> returns the root node of a balanced binary tree from a list of values.
If the list is sorted, then the tree is a binary search tree (BST). A BST has the important property
that if you do an in-order traversal of the nodes, you will visit them in order.
A recursive implementation of in-order traversal is straightforward.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="n">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">traverse_recursive</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>Let‚Äôs test it with a small sorted list of integers and verify that the nodes are printed out in order.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">make_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Now, what if we insist on traversing <strong>without</strong> recursion? In lieu of the call stack, we need to
maintain our own stack. Each item in our stack would hold the same information as a call frame.
In <span class="docutils literal"><span class="pre">traverse_recursive</span></span> there are two potential recursive calls, each call adding another frame to
the call stack. Since a recursive call suspends the calling frame, our stack must maintain a
state - whether or not the left side of the BST has been examined. Let‚Äôs designate the possibilities
for this state <span class="docutils literal"><span class="pre">"left"</span></span> and <span class="docutils literal"><span class="pre">"right"</span></span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_iterative</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"left"</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"right"</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
</pre></div>
</div>
<p>Each call frame becomes, in our stack, a pair of items - as the stack is popped off, the left side of
each node is examined before the right. The analogue of a recursive call is pushing another pair to the stack.
Let‚Äôs test <span class="docutils literal"><span class="pre">traverse_iterative</span></span> on the same BST.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_iterative</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Note that an in-order traversal is different from a depth-first search (DFS). To implement DFS iteratively,
we simply maintain a stack of nodes without the additional state. This is because DFS first checks whether
the target node has been found (and if so, exits) <strong>before</strong> adding the child nodes to the stack. Hence there
is no reason to ‚Äúremember‚Äù the parent node. Formally, DFS on a binary tree is equivalent to a pre-order traversal.</p>
<p>The iterative implementation of in-order tree traversal is less intuitive than the recursive version, which nicely
illustrates that recursion is sometimes <strong>much easier</strong> than iteration. Though iteration has the advantage
of not growing the call stack, and readily leads to tail recursion.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">traverse_tail_recursive</span><span class="p">(</span><span class="n">stack</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">node</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"left"</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="s2">"right"</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">))</span>

    <span class="n">traverse_tail_recursive</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span>
</pre></div>
</div>
<p>Calling <span class="docutils literal"><span class="pre">traverse_tail_recursive</span></span> with the same tree but wrapped inside of a stack:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">traverse_tail_recursive</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s2">"left"</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Python does not offer tail call optimization, but in languages that do, this example suggests a recipe
for turning a recursive function into a tail recursive function: via an intermediate iterative implementation.</p>
]]></description>
             <pubDate>Fri, 13 Jul 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/07/09/metaclass_intro.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/07/09/metaclass_intro.html</guid>
            <title><![CDATA[Metaclasses made simple]]></title>
            <description><![CDATA[<h1>Metaclasses made simple</h1>
<p>You probably have added the <span class="docutils literal"><span class="pre">__repr__</span></span> method to a Python class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Cat</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"&lt;üòª&gt;"</span>
</pre></div>
</div>
<p>This gives a customized representation to the instance at the command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Cat</span><span class="p">()</span>
<span class="go">&lt;üòª&gt;</span>
</pre></div>
</div>
<p>However, this <span class="docutils literal"><span class="pre">__repr__</span></span> has no effect on the class itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">Cat</span>
<span class="go">&lt;class 'meta_cats.Cat'&gt;</span>
</pre></div>
</div>
<p>The reason is that a method defined on a class acts on instances of the class but not
the class itself. But what if the class is itself an instance? An instance of what class?
Python provides an easy way to find out:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span>
<span class="go">&lt;class 'type'&gt;</span>
</pre></div>
</div>
<p>So we see that a class is an instance of the built-in class <span class="docutils literal"><span class="pre">type</span></span>. This means that we
should be able to subclass <span class="docutils literal"><span class="pre">type</span></span>, add methods to it, and instantiate classes using
our customized type. Here is a small example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">MetaCat</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">repr_string</span>
</pre></div>
</div>
<p>Note that <span class="docutils literal"><span class="pre">MetaCat</span></span> descends from <span class="docutils literal"><span class="pre">type</span></span> and has a <span class="docutils literal"><span class="pre">__repr__</span></span> method that has a parameter
<span class="docutils literal"><span class="pre">cls</span></span>. This is to emphasize that instances of <span class="docutils literal"><span class="pre">MetaCat</span></span> are themselves classes.</p>
<p>We can instantiate a class in the usual way, except for an additional optional parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">FancyCat</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaCat</span><span class="p">):</span>
    <span class="n">repr_string</span> <span class="o">=</span> <span class="s2">"&lt;class üòª&gt;"</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">metaclass</span></span> parameter in the class definition instructs Python to make an instance of <span class="docutils literal"><span class="pre">MetaCat</span></span>
instead of <span class="docutils literal"><span class="pre">type</span></span>. Let‚Äôs verify this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">FancyCat</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MetaCat</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, let‚Äôs see what happens when we evaluate the class <span class="docutils literal"><span class="pre">FancyCat</span></span> on the Python command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">FancyCat</span>
<span class="go">&lt;class üòª&gt;</span>
</pre></div>
</div>
<p>Indeed, the <span class="docutils literal"><span class="pre">__repr__</span></span> method defined on <span class="docutils literal"><span class="pre">MetaCat</span></span> is called, and returns a customized representaion.</p>
<p>To summarize, every class in Python is an instance of some class, often referred to as a metaclass to
distinguish it from other classes. <span class="docutils literal"><span class="pre">type</span></span> is the built-in metaclass of which <span class="docutils literal"><span class="pre">int</span></span>, <span class="docutils literal"><span class="pre">dict</span></span>, and your own
classes are instances. And just like with most classes, you can subclass <span class="docutils literal"><span class="pre">type</span></span> to make custom metaclasses,
analogous to subclassing <span class="docutils literal"><span class="pre">object</span></span> to make custom classes.</p>
]]></description>
             <pubDate>Mon, 09 Jul 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/06/24/c_style_enum.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/06/24/c_style_enum.html</guid>
            <title><![CDATA[A C style enum in Python]]></title>
            <description><![CDATA[<h1>A C style enum in Python</h1>
<p>The <a class="reference external" href="https://docs.python.org/3/library/enum.html#creating-an-enum">enum</a> standard module allows you to
make names whose values are arbitrary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">RED</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">GREEN</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">BLUE</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>It is convenient to use <span class="docutils literal"><span class="pre">Color.RED</span></span> in code because the compiler/interpreter will ensure against
typos, and sensibly chosen names will enhance readibility. However, unlike in C, Python‚Äôs <span class="docutils literal"><span class="pre">enum</span></span>
forces you to assign values. It would be nice if we can simply write</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">RED</span>
    <span class="n">GREEN</span>
    <span class="n">BLUE</span>
</pre></div>
</div>
<p>and have the attributes autoincrement. It turns out that with a little metaprogramming, we can.</p>
<p>Python 3 introduced <span class="docutils literal"><span class="pre">__prepare__</span></span>, which is a method on the metaclass invoked before class creation.
It by default returns a dictionary, which will contain the class attributes required for class creation.
For example, the statement <span class="docutils literal"><span class="pre">RED</span> <span class="pre">=</span> <span class="pre">1</span></span> above has the effect of adding a key/value pair to this
dictionary: <span class="docutils literal"><span class="pre">prepared_dict['RED']</span> <span class="pre">=</span> <span class="pre">1</span></span>.</p>
<p>The idea is to override <span class="docutils literal"><span class="pre">__prepare__</span></span> and return a customized dictonary that assigns each key the next
available integer. Here is an implementation of this dictionary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">AutoDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"__"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">"__"</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Under a class definition, for each variable that appears in an expression - as opposed to the left hand side
of an assignment - Python will look up its value first in this dictionary, calling the <span class="docutils literal"><span class="pre">__getitem__</span></span>
method, which in turn <strong>assigns</strong> to it the next integer.</p>
<p>Then we create a metaclass with a <span class="docutils literal"><span class="pre">__prepare__</span></span> method that returns an instance of <span class="docutils literal"><span class="pre">AutoDict</span></span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">EnumMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AutoDict</span><span class="p">()</span>
</pre></div>
</div>
<p>and a base class that instantiates <span class="docutils literal"><span class="pre">EnumMeta</span></span></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">class</span> <span class="nc">Enum</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">EnumMeta</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Let‚Äôs try running the example above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">RED</span>
<span class="gp">... </span>    <span class="n">GREEN</span>
<span class="gp">... </span>    <span class="n">BLUE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">RED</span>
<span class="go">0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">GREEN</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">BLUE</span>
<span class="go">2</span>
</pre></div>
</div>
<p>So we have an enum class that automatically assign and increment values to its attributes.</p>
]]></description>
             <pubDate>Sun, 24 Jun 2018 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>https://scotchka.github.io/blog/html/2018/06/16/balance_brackets.html</link>
            <guid>https://scotchka.github.io/blog/html/2018/06/16/balance_brackets.html</guid>
            <title><![CDATA[Balance brackets with the call stack]]></title>
            <description><![CDATA[<h1>Balance brackets with the call stack</h1>
<p>A classic algorithm problem is to determine whether a string
containing some sequences of brackets (possibly of different types)
is balanced, that is, whether the string is a valid mathematical
expression. For example, <span class="docutils literal"><span class="pre">()</span></span> is balanced, and <span class="docutils literal"><span class="pre">)(</span></span> is not.</p>
<p>The typical solution involves iterating thru the string and maintaining
a stack - pushing an opening bracket onto the stack when encountered,
and popping it off when the corresponding closing bracket is seen.</p>
<p>But why not, instead of making our own stack, use the call stack? Python‚Äôs
<span class="docutils literal"><span class="pre">inspect</span></span> module allows us to do just that.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="kn">import</span> <span class="nn">inspect</span>
</pre></div>
</div>
<p>This module‚Äôs <span class="docutils literal"><span class="pre">stack</span></span> function returns the call stack from top to bottom,
so the previous frame is <span class="docutils literal"><span class="pre">stack()[1]</span></span>.</p>
<p>We define a function <span class="docutils literal"><span class="pre">_stack</span></span> that
iterates through a list of characters. Upon seeing an opening bracket, it pushes
onto the call stack by calling itself, and in case of a closing bracket, pops by
simply returning. By inspecting the previous frame, we ensure that the closing
bracket matches the most recent opening bracket, and that there are no opening
brackets left on the call stack at the end,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">_stack</span><span class="p">(</span><span class="n">chars</span><span class="p">):</span>
    <span class="sd">"""Push/pop frames to/from call stack."""</span>
    <span class="k">while</span> <span class="n">chars</span><span class="p">:</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">chars</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">BRACKETS</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">_stack</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>  <span class="c1"># push</span>
        <span class="k">elif</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">BRACKETS</span><span class="p">:</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">previous</span><span class="o">.</span><span class="n">function</span> <span class="o">!=</span> <span class="s2">"_stack"</span>
                <span class="ow">or</span> <span class="n">previous</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="s2">"char"</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BRACKETS</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>
            <span class="k">return</span>  <span class="c1"># pop</span>

    <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">function</span> <span class="o">==</span> <span class="s2">"_stack"</span><span class="p">:</span>  <span class="c1"># check no brackets remain</span>
        <span class="k">raise</span> <span class="ne">IndexError</span>
</pre></div>
</div>
<p>where <span class="docutils literal"><span class="pre">BRACKETS</span></span> is a mapping of closing to opening brackets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="n">BRACKETS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">")"</span><span class="p">:</span> <span class="s2">"("</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">:</span> <span class="s2">"["</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">:</span> <span class="s2">"{"</span><span class="p">}</span>
</pre></div>
</div>
<p>In the event of an unbalanced expression, <span class="docutils literal"><span class="pre">_stack</span></span> raises <span class="docutils literal"><span class="pre">IndexError</span></span>,
hence we define <span class="docutils literal"><span class="pre">is_balanced</span></span> that wraps <span class="docutils literal"><span class="pre">_stack</span></span> inside of a try/except:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="k">def</span> <span class="nf">is_balanced</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="sd">"""Check whether brackets in given string balanced."""</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_stack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
<p>Some test examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span/><span class="gp">&gt;&gt;&gt; </span><span class="n">is_balanced</span><span class="p">(</span><span class="s2">"[]"</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_balanced</span><span class="p">(</span><span class="s2">")("</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_balanced</span><span class="p">(</span><span class="s2">"{[}]"</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_balanced</span><span class="p">(</span><span class="s2">"("</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
]]></description>
             <pubDate>Sat, 16 Jun 2018 00:00:00 -0700</pubDate>
        </item>
    
    </channel>
</rss>